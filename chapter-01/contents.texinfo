@node Introduction
@chapter Introduction

@quotation
The computer is simply an instrument whose music is ideas.
@author Alan Kay
@end quotation

@*

@cuis{} offers the possibility to easily design your own Morphs --
widgets you can interact with and later integrate in your GUI
application. There are three ways to design a custom Morph: an
aggregate of existing Morphs, a design from scratch or a combination
of the two former approaches.

Building a new Morph with an aggregate of existing Morphs is mainly
about laying out together Morphs and let the aggregated Morphs manage
the low level drawings and input event operations. When there is a
need for a custom Morph, this is the path to investigate first; if
there is no way to do so, then consider designing from scratch a
Morph.

Designing from scratch a Morph requires to deal with its appearance
and the handling of the input events; for the former, Cuis offers a
vector graphics anti-aliased canvas, the latter is done with a
mechanism to filter and to handle mouse and keyboard events occurring
in the scope of the custom Morph.

Let's start right away with a design from scratch.

@menu
* A first glimpse::
* Mouse event::
* Keyboard event::
@end menu

@node A first glimpse
@section A first glimpse
It's easy to create custom morphs. Just create a subclass of an
existing morph class. Then implement the @method{drawOn:} method or
add and layout sub morphs.

Let's make an example that draws an ellipse. Making it a subclass of
@class{BoxMorph} gives it an @smalltalk{extent} instance variable
which specifies its width and height.

@smalltalkExample{BoxMorph subclass: #EllipseDemo
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'ArtOfMorph'}

We adjust its default extent@footnote{Observe the backtricks to
improve performance at execution.},

@smalltalkMethod{defaultExtent,
@return{} `200@@200`}

In our @class{EllipseDemo}, the @smalltalk{extent} represents the
lengths of the ox and oy axis of the ellipse. We use it to draw it
accordingly:

@smalltalkMethod{drawOn: aCanvas,
| radius |
radius := extent / 2.0.
aCanvas fillColor: Color purple do: [
   aCanvas ellipseCenter: radius radius: radius]}
   
Finally, we instruct @cuis{} we want to use the Vector Graphic engine

@smalltalkMethod{requiresVectorCanvas,
@return{} true}

@strong{Important.} The drawing always operates in the own morph
coordinates system and we have to ensure our drawing operations remain
in the bond defined by the morph origin, in the top-left corner, and
its bottom-right corner delimited by its @smalltalk{extent} attribute,
a point.

@figure{Ellipse with axes,ch01-EllipseDemo-Axes,5}


@node Mouse event
@section Mouse event

@node Keyboard event
@section Keyboard event
